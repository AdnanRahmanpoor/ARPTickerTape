

================================================================================
FILE: ApiFetcher.cpp
================================================================================

0001 | #include <windows.h>  // Added this include
0002 | #include <winhttp.h>
0003 | #include "ApiFetcher.h"
0004 | #include <string>
0005 | #include <sstream>
0006 | 
0007 | double ApiFetcher::FetchPrice(const std::wstring& symbol) {
0008 |     double price = 0.0;
0009 |     HINTERNET hSession = WinHttpOpen(L"TickerTape", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);
0010 |     if (!hSession) return price;
0011 | 
0012 |     HINTERNET hConnect = WinHttpConnect(hSession, L"query1.finance.yahoo.com", INTERNET_DEFAULT_HTTPS_PORT, 0);
0013 |     if (!hConnect) {
0014 |         WinHttpCloseHandle(hSession);
0015 |         return price;
0016 |     }
0017 | 
0018 |     std::wstring path = L"/v8/finance/chart/" + symbol + L"?range=1d&includePrePost=false&interval=1d";
0019 |     HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", path.c_str(), NULL, NULL, NULL, WINHTTP_FLAG_SECURE);
0020 |     if (!hRequest) {
0021 |         WinHttpCloseHandle(hConnect);
0022 |         WinHttpCloseHandle(hSession);
0023 |         return price;
0024 |     }
0025 | 
0026 |     if (WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0) && WinHttpReceiveResponse(hRequest, NULL)) {
0027 |         DWORD dwSize = 0;
0028 |         DWORD dwDownloaded = 0;
0029 |         std::string response;
0030 |         do {
0031 |             WinHttpQueryDataAvailable(hRequest, &dwSize);
0032 |             if (!dwSize) break;
0033 |             char* pszOutBuffer = new char[dwSize + 1];
0034 |             if (!pszOutBuffer) break;
0035 |             if (WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded)) {
0036 |                 pszOutBuffer[dwDownloaded] = '\0';
0037 |                 response += pszOutBuffer;
0038 |             }
0039 |             delete[] pszOutBuffer;
0040 |         } while (dwSize > 0);
0041 | 
0042 |         // Simple JSON parse for "regularMarketPrice"
0043 |         size_t pos = response.find("\"regularMarketPrice\":");
0044 |         if (pos != std::string::npos) {
0045 |             pos += 21;  // Skip key
0046 |             size_t end = response.find_first_of(",}", pos);
0047 |             if (end != std::string::npos) {
0048 |                 std::string priceStr = response.substr(pos, end - pos);
0049 |                 std::stringstream ss(priceStr);
0050 |                 ss >> price;
0051 |             }
0052 |         }
0053 |     }
0054 | 
0055 |     WinHttpCloseHandle(hRequest);
0056 |     WinHttpCloseHandle(hConnect);
0057 |     WinHttpCloseHandle(hSession);
0058 |     return price;
0059 | }


================================================================================
FILE: ApiFetcher.h
================================================================================

0001 | #ifndef API_FETCHER_H
0002 | #define API_FETCHER_H
0003 | 
0004 | #include <string>
0005 | 
0006 | class ApiFetcher {
0007 | public:
0008 |     static double FetchPrice(const std::wstring& symbol);
0009 | };
0010 | 
0011 | #endif

================================================================================
FILE: ConfigManager.cpp
================================================================================

0001 | #include "ConfigManager.h"
0002 | #include <windows.h>
0003 | #include <string>
0004 | #include <vector>
0005 | #include <sstream>
0006 | #include <shlwapi.h>  // For PathFileExists
0007 | 
0008 | #pragma comment(lib, "shlwapi.lib")
0009 | 
0010 | std::vector<std::wstring> ConfigManager::symbols;
0011 | int ConfigManager::refreshInterval = 60;
0012 | int ConfigManager::scrollSpeed = 5;
0013 | std::wstring ConfigManager::colorScheme = L"Amber";
0014 | int ConfigManager::windowHeight = 30;
0015 | int ConfigManager::fontSize = 16;
0016 | 
0017 | void ConfigManager::LoadConfig() {
0018 |     // Create default config if it doesn't exist
0019 |     if (!PathFileExists(TEXT("ticker_config.ini"))) {
0020 |         SaveConfig();  // Create default
0021 |         return;
0022 |     }
0023 | 
0024 |     TCHAR buffer[1024];
0025 | 
0026 |     // Load symbols
0027 |     GetPrivateProfileString(TEXT("Settings"), TEXT("Symbols"), TEXT("AAPL,GOOGL,MSFT,TSLA,BTC-USD,ETH-USD"),
0028 |         buffer, 1024, TEXT("ticker_config.ini"));
0029 |     std::wstring symbolsStr = buffer;
0030 | 
0031 |     // Parse comma-separated symbols
0032 |     std::wstringstream ss(symbolsStr);
0033 |     std::wstring token;
0034 |     symbols.clear();
0035 |     while (std::getline(ss, token, L',')) {
0036 |         // Trim whitespace
0037 |         token.erase(0, token.find_first_not_of(L" \t"));
0038 |         token.erase(token.find_last_not_of(L" \t") + 1);
0039 |         if (!token.empty()) {
0040 |             symbols.push_back(token);
0041 |         }
0042 |     }
0043 | 
0044 |     // Load other settings
0045 |     refreshInterval = GetPrivateProfileInt(TEXT("Settings"), TEXT("RefreshInterval"), 60, TEXT("ticker_config.ini"));
0046 |     scrollSpeed = GetPrivateProfileInt(TEXT("Settings"), TEXT("ScrollSpeed"), 5, TEXT("ticker_config.ini"));
0047 | 
0048 |     GetPrivateProfileString(TEXT("Settings"), TEXT("ColorScheme"), TEXT("Green"),
0049 |         buffer, 1024, TEXT("ticker_config.ini"));
0050 |     colorScheme = buffer;
0051 | 
0052 |     windowHeight = GetPrivateProfileInt(TEXT("Settings"), TEXT("WindowHeight"), 30, TEXT("ticker_config.ini"));
0053 |     fontSize = GetPrivateProfileInt(TEXT("Settings"), TEXT("FontSize"), 16, TEXT("ticker_config.ini"));
0054 | 
0055 |     // Validate ranges
0056 |     if (refreshInterval < 10) refreshInterval = 10;
0057 |     if (refreshInterval > 3600) refreshInterval = 3600;
0058 | 
0059 |     if (scrollSpeed < 1) scrollSpeed = 1;
0060 |     if (scrollSpeed > 50) scrollSpeed = 50;
0061 | 
0062 |     if (windowHeight < 20) windowHeight = 20;
0063 |     if (windowHeight > 200) windowHeight = 200;
0064 | 
0065 |     if (fontSize < 8) fontSize = 8;
0066 |     if (fontSize > 72) fontSize = 72;
0067 | 
0068 |     // Ensure we have at least one symbol
0069 |     if (symbols.empty()) {
0070 |         symbols.push_back(L"AAPL");
0071 |         symbols.push_back(L"GOOGL");
0072 |         symbols.push_back(L"MSFT");
0073 |     }
0074 | 
0075 |     // Debug output
0076 |     OutputDebugString(TEXT("Config loaded successfully\n"));
0077 |     TCHAR dbg[256];
0078 |     wsprintf(dbg, TEXT("Symbols: %d, Refresh: %d, Height: %d, FontSize: %d\n"),
0079 |         (int)symbols.size(), refreshInterval, windowHeight, fontSize);
0080 |     OutputDebugString(dbg);
0081 | }
0082 | 
0083 | void ConfigManager::SaveConfig() {
0084 |     // Build symbols string
0085 |     std::wstring symbolsStr;
0086 |     for (size_t i = 0; i < symbols.size(); ++i) {
0087 |         if (i > 0) symbolsStr += L",";
0088 |         symbolsStr += symbols[i];
0089 |     }
0090 | 
0091 |     // If no symbols, use defaults
0092 |     if (symbolsStr.empty()) {
0093 |         symbolsStr = L"AAPL,GOOGL,MSFT,BTC-USD,ETH-USD";
0094 |     }
0095 | 
0096 |     WritePrivateProfileString(TEXT("Settings"), TEXT("Symbols"), symbolsStr.c_str(), TEXT("ticker_config.ini"));
0097 | 
0098 |     // Convert integers to strings and save
0099 |     TCHAR buffer[32];
0100 | 
0101 |     wsprintf(buffer, TEXT("%d"), refreshInterval);
0102 |     WritePrivateProfileString(TEXT("Settings"), TEXT("RefreshInterval"), buffer, TEXT("ticker_config.ini"));
0103 | 
0104 |     wsprintf(buffer, TEXT("%d"), scrollSpeed);
0105 |     WritePrivateProfileString(TEXT("Settings"), TEXT("ScrollSpeed"), buffer, TEXT("ticker_config.ini"));
0106 | 
0107 |     WritePrivateProfileString(TEXT("Settings"), TEXT("ColorScheme"), colorScheme.c_str(), TEXT("ticker_config.ini"));
0108 | 
0109 |     wsprintf(buffer, TEXT("%d"), windowHeight);
0110 |     WritePrivateProfileString(TEXT("Settings"), TEXT("WindowHeight"), buffer, TEXT("ticker_config.ini"));
0111 | 
0112 |     wsprintf(buffer, TEXT("%d"), fontSize);
0113 |     WritePrivateProfileString(TEXT("Settings"), TEXT("FontSize"), buffer, TEXT("ticker_config.ini"));
0114 | 
0115 |     OutputDebugString(TEXT("Config saved successfully\n"));
0116 | }


================================================================================
FILE: ConfigManager.h
================================================================================

0001 | #ifndef CONFIG_MANAGER_H
0002 | #define CONFIG_MANAGER_H
0003 | 
0004 | #include <vector>
0005 | #include <string>
0006 | 
0007 | class ConfigManager {
0008 | public:
0009 |     static void LoadConfig();
0010 |     static void SaveConfig();
0011 | 
0012 |     static std::vector<std::wstring> symbols;
0013 |     static int refreshInterval;
0014 |     static int scrollSpeed;
0015 |     static std::wstring colorScheme;
0016 |     static int windowHeight;
0017 |     static int fontSize;
0018 | };
0019 | 
0020 | #endif


================================================================================
FILE: main.cpp
================================================================================

0001 | // main.cpp
0002 | #include <windows.h>
0003 | #include <winhttp.h>
0004 | #include <shellapi.h>  // For SHAppBarMessage
0005 | #include <string>
0006 | #include <vector>
0007 | #include <map>
0008 | #include <thread>
0009 | #include <mutex>
0010 | #include <fstream>
0011 | #include <sstream>
0012 | #include <algorithm>
0013 | #include "TickerManager.h"
0014 | #include "ApiFetcher.h"
0015 | #include "ConfigManager.h"
0016 | #include "Renderer.h"
0017 | 
0018 | #define TIMER_SCROLL 1
0019 | #define TIMER_UPDATE 2
0020 | #define SCROLL_INTERVAL 80  // ms for ~60 FPS
0021 | #define APPBAR_CALLBACK WM_APP + 1
0022 | 
0023 | LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
0024 | void UpdateTickerText(HWND hWnd);
0025 | void DockWindow(HWND hWnd, bool top);
0026 | void UndockWindow(HWND hWnd);
0027 | void UpdateWindowSize(HWND hWnd);
0028 | void RecalculateCharWidth(HWND hWnd);
0029 | 
0030 | // Global variables
0031 | std::wstring tickerText = L"Loading...";
0032 | int scrollOffset = 0;
0033 | int charWidth = 10;  // Approximate, calculated later
0034 | int windowWidth = 0;
0035 | int windowHeight = 30;
0036 | std::mutex textMutex;
0037 | bool isPaused = false;
0038 | bool isHidden = false;
0039 | HMENU hMenu;
0040 | bool isDocked = false;
0041 | bool isDockedTop = true;
0042 | 
0043 | int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
0044 |     ConfigManager::LoadConfig();
0045 | 
0046 |     WNDCLASS wc = { 0 };
0047 |     wc.style = CS_HREDRAW | CS_VREDRAW;
0048 |     wc.lpfnWndProc = WndProc;
0049 |     wc.hInstance = hInstance;
0050 |     wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
0051 |     wc.lpszClassName = TEXT("TickerTapeClass");
0052 |     wc.hCursor = LoadCursor(NULL, IDC_ARROW);
0053 | 
0054 |     RegisterClass(&wc);
0055 | 
0056 |     // Get screen dimensions for flexible width
0057 |     int screenWidth = GetSystemMetrics(SM_CXSCREEN);
0058 | 
0059 |     HWND hWnd = CreateWindowEx(
0060 |         WS_EX_TOOLWINDOW | WS_EX_TOPMOST,  // Start as topmost but not docked
0061 |         TEXT("TickerTapeClass"),
0062 |         TEXT("TickerTape"),
0063 |         WS_POPUP | WS_VISIBLE,
0064 |         100, 100, screenWidth, ConfigManager::windowHeight,  // Start at reasonable position
0065 |         NULL, NULL, hInstance, NULL);
0066 | 
0067 |     if (!hWnd) return 1;
0068 | 
0069 |     // Create context menu
0070 |     hMenu = CreatePopupMenu();
0071 |     AppendMenu(hMenu, MF_STRING, 1, TEXT("Pause"));
0072 |     AppendMenu(hMenu, MF_STRING, 2, TEXT("Resume"));
0073 |     AppendMenu(hMenu, MF_STRING, 3, TEXT("Reload Config"));
0074 |     AppendMenu(hMenu, MF_STRING, 5, TEXT("Dock Top"));
0075 |     AppendMenu(hMenu, MF_STRING, 6, TEXT("Dock Bottom"));
0076 |     AppendMenu(hMenu, MF_STRING, 7, TEXT("Undock"));
0077 |     AppendMenu(hMenu, MF_STRING, 4, TEXT("Exit"));
0078 | 
0079 |     // Register hotkeys
0080 |     RegisterHotKey(hWnd, 100, MOD_CONTROL | MOD_ALT, 'P');  // Ctrl+Alt+P pause/resume
0081 |     RegisterHotKey(hWnd, 101, MOD_CONTROL | MOD_ALT, 'H');  // Ctrl+Alt+H hide/show
0082 | 
0083 |     // Start update thread
0084 |     std::thread updateThread([]() {
0085 |         while (true) {
0086 |             UpdateTickerText(NULL);
0087 |             Sleep(ConfigManager::refreshInterval * 1000);
0088 |         }
0089 |         });
0090 |     updateThread.detach();
0091 | 
0092 |     // Initial setup
0093 |     RecalculateCharWidth(hWnd);
0094 |     UpdateTickerText(hWnd);
0095 |     // Don't auto-dock on startup - let user choose
0096 | 
0097 |     // Timers
0098 |     SetTimer(hWnd, TIMER_SCROLL, SCROLL_INTERVAL, NULL);
0099 |     SetTimer(hWnd, TIMER_UPDATE, ConfigManager::refreshInterval * 1000, NULL);
0100 | 
0101 |     MSG msg;
0102 |     while (GetMessage(&msg, NULL, 0, 0)) {
0103 |         TranslateMessage(&msg);
0104 |         DispatchMessage(&msg);
0105 |     }
0106 | 
0107 |     UnregisterHotKey(hWnd, 100);
0108 |     UnregisterHotKey(hWnd, 101);
0109 | 
0110 |     return (int)msg.wParam;
0111 | }
0112 | 
0113 | LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
0114 |     static DWORD lastClickTime = 0;
0115 | 
0116 |     switch (message) {
0117 |     case WM_PAINT: {
0118 |         PAINTSTRUCT ps;
0119 |         HDC hdc = BeginPaint(hWnd, &ps);
0120 |         Renderer::Render(hdc, tickerText, scrollOffset, windowWidth, windowHeight, charWidth);
0121 |         EndPaint(hWnd, &ps);
0122 |         break;
0123 |     }
0124 |     case WM_TIMER:
0125 |         if (wParam == TIMER_SCROLL && !isPaused && !isHidden) {
0126 |             if (!tickerText.empty()) {
0127 |                 int textPixelWidth = ((int)tickerText.length() / 2) * charWidth;
0128 |                 if (textPixelWidth > 0) {
0129 |                     scrollOffset = (scrollOffset + ConfigManager::scrollSpeed) % textPixelWidth;
0130 |                 }
0131 |             }
0132 |             InvalidateRect(hWnd, NULL, TRUE);
0133 |         }
0134 |         else if (wParam == TIMER_UPDATE) {
0135 |             UpdateTickerText(hWnd);
0136 |         }
0137 |         break;
0138 |     case WM_HOTKEY:
0139 |         if (wParam == 100) {
0140 |             isPaused = !isPaused;
0141 |         }
0142 |         else if (wParam == 101) {
0143 |             isHidden = !isHidden;
0144 |             ShowWindow(hWnd, isHidden ? SW_HIDE : SW_SHOW);
0145 |         }
0146 |         break;
0147 |     case WM_LBUTTONDOWN: {
0148 |         DWORD currentTime = GetTickCount();
0149 |         if (currentTime - lastClickTime < GetDoubleClickTime()) {
0150 |             // Double click detected - toggle dock state
0151 |             if (isDocked) {
0152 |                 UndockWindow(hWnd);
0153 |             }
0154 |             else {
0155 |                 DockWindow(hWnd, true);  // Dock to top by default
0156 |             }
0157 |         }
0158 |         else {
0159 |             // Single click - start dragging if not docked
0160 |             if (!isDocked) {
0161 |                 // Begin manual window dragging
0162 |                 ReleaseCapture();
0163 |                 SendMessage(hWnd, WM_NCLBUTTONDOWN, HTCAPTION, lParam);
0164 |                 return 0;
0165 |             }
0166 |         }
0167 |         lastClickTime = currentTime;
0168 |         break;
0169 |     }
0170 |     case WM_RBUTTONUP: {
0171 |         POINT pt;
0172 |         GetCursorPos(&pt);
0173 |         TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);
0174 |         break;
0175 |     }
0176 |     case WM_COMMAND:
0177 |         switch (LOWORD(wParam)) {
0178 |         case 1: isPaused = true; break;
0179 |         case 2: isPaused = false; break;
0180 |         case 3:
0181 |             ConfigManager::LoadConfig();
0182 |             KillTimer(hWnd, TIMER_UPDATE);
0183 |             SetTimer(hWnd, TIMER_UPDATE, ConfigManager::refreshInterval * 1000, NULL);
0184 |             RecalculateCharWidth(hWnd);
0185 |             UpdateWindowSize(hWnd);
0186 |             // Only re-dock if we were previously docked
0187 |             // Don't force docking on config reload
0188 |             UpdateTickerText(hWnd);
0189 |             InvalidateRect(hWnd, NULL, TRUE);
0190 |             break;
0191 |         case 5: DockWindow(hWnd, true); break;   // Dock Top
0192 |         case 6: DockWindow(hWnd, false); break;  // Dock Bottom
0193 |         case 7: UndockWindow(hWnd); break;
0194 |         case 4: DestroyWindow(hWnd); break;
0195 |         }
0196 |         break;
0197 |     case WM_SIZE:
0198 |         windowWidth = LOWORD(lParam);
0199 |         windowHeight = HIWORD(lParam);
0200 |         break;
0201 |     case WM_CREATE:
0202 |         RecalculateCharWidth(hWnd);
0203 |         break;
0204 |     case WM_SETCURSOR:
0205 |         if (LOWORD(lParam) == HTCLIENT) {
0206 |             SetCursor(LoadCursor(NULL, isDocked ? IDC_ARROW : IDC_SIZEALL));
0207 |             return TRUE;
0208 |         }
0209 |         return DefWindowProc(hWnd, message, wParam, lParam);
0210 |     case APPBAR_CALLBACK:
0211 |         // Minimal handling to prevent infinite loops
0212 |         if (wParam == ABN_POSCHANGED && isDocked) {
0213 |             // Just acknowledge the message, don't reposition
0214 |             return 0;
0215 |         }
0216 |         break;
0217 |     case WM_DESTROY:
0218 |         if (isDocked) UndockWindow(hWnd);
0219 |         PostQuitMessage(0);
0220 |         break;
0221 |     default:
0222 |         return DefWindowProc(hWnd, message, wParam, lParam);
0223 |     }
0224 |     return 0;
0225 | }
0226 | 
0227 | void DockWindow(HWND hWnd, bool top) {
0228 |     // Prevent re-entry
0229 |     static bool isDocking = false;
0230 |     if (isDocking) return;
0231 |     isDocking = true;
0232 | 
0233 |     // If already docked, undock first without recursion
0234 |     if (isDocked) {
0235 |         APPBARDATA abd = { 0 };
0236 |         abd.cbSize = sizeof(APPBARDATA);
0237 |         abd.hWnd = hWnd;
0238 |         SHAppBarMessage(ABM_REMOVE, &abd);
0239 |         isDocked = false;
0240 |     }
0241 | 
0242 |     APPBARDATA abd = { 0 };
0243 |     abd.cbSize = sizeof(APPBARDATA);
0244 |     abd.hWnd = hWnd;
0245 |     abd.uCallbackMessage = APPBAR_CALLBACK;
0246 | 
0247 |     // Register as appbar
0248 |     if (SHAppBarMessage(ABM_NEW, &abd) == 0) {
0249 |         isDocking = false;
0250 |         return;
0251 |     }
0252 | 
0253 |     isDocked = true;
0254 |     isDockedTop = top;
0255 | 
0256 |     // Get the primary monitor work area for consistent behavior
0257 |     RECT workRect;
0258 |     SystemParametersInfo(SPI_GETWORKAREA, 0, &workRect, 0);
0259 | 
0260 |     abd.uEdge = top ? ABE_TOP : ABE_BOTTOM;
0261 |     abd.rc.left = workRect.left;
0262 |     abd.rc.right = workRect.right;
0263 | 
0264 |     if (top) {
0265 |         abd.rc.top = workRect.top;
0266 |         abd.rc.bottom = workRect.top + ConfigManager::windowHeight;
0267 |     }
0268 |     else {
0269 |         abd.rc.top = workRect.bottom - ConfigManager::windowHeight;
0270 |         abd.rc.bottom = workRect.bottom;
0271 |     }
0272 | 
0273 |     // Set position immediately
0274 |     SHAppBarMessage(ABM_SETPOS, &abd);
0275 | 
0276 |     // Position the window - use HWND_TOP instead of HWND_TOPMOST to avoid conflicts
0277 |     SetWindowPos(hWnd, HWND_TOP,
0278 |         abd.rc.left, abd.rc.top,
0279 |         abd.rc.right - abd.rc.left,
0280 |         abd.rc.bottom - abd.rc.top,
0281 |         SWP_SHOWWINDOW | SWP_NOACTIVATE);
0282 | 
0283 |     isDocking = false;
0284 | }
0285 | 
0286 | void UndockWindow(HWND hWnd) {
0287 |     if (!isDocked) return;
0288 | 
0289 |     APPBARDATA abd = { 0 };
0290 |     abd.cbSize = sizeof(APPBARDATA);
0291 |     abd.hWnd = hWnd;
0292 | 
0293 |     // Unregister from appbar
0294 |     SHAppBarMessage(ABM_REMOVE, &abd);
0295 | 
0296 |     isDocked = false;
0297 | 
0298 |     // Get current position to maintain it when undocking
0299 |     RECT currentRect;
0300 |     GetWindowRect(hWnd, &currentRect);
0301 | 
0302 |     // Remove topmost and make it a normal draggable window
0303 |     SetWindowPos(hWnd, HWND_NOTOPMOST,
0304 |         currentRect.left, currentRect.top,
0305 |         GetSystemMetrics(SM_CXSCREEN), ConfigManager::windowHeight,
0306 |         SWP_SHOWWINDOW | SWP_FRAMECHANGED | SWP_NOACTIVATE);
0307 | }
0308 | 
0309 | void UpdateWindowSize(HWND hWnd) {
0310 |     int screenWidth = GetSystemMetrics(SM_CXSCREEN);
0311 |     SetWindowPos(hWnd, NULL, 0, 0, screenWidth, ConfigManager::windowHeight,
0312 |         SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
0313 | }
0314 | 
0315 | void RecalculateCharWidth(HWND hWnd) {
0316 |     HDC hdc = GetDC(hWnd);
0317 |     HFONT hFont = Renderer::GetFont();
0318 |     HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
0319 | 
0320 |     SIZE size;
0321 |     GetTextExtentPoint32(hdc, TEXT("A"), 1, &size);
0322 |     charWidth = size.cx;
0323 | 
0324 |     SelectObject(hdc, hOldFont);
0325 |     DeleteObject(hFont);
0326 |     ReleaseDC(hWnd, hdc);
0327 | }
0328 | 
0329 | void UpdateTickerText(HWND hWnd) {
0330 |     std::lock_guard<std::mutex> lock(textMutex);
0331 |     std::wstring newText;
0332 | 
0333 |     for (const auto& symbol : ConfigManager::symbols) {
0334 |         double price = ApiFetcher::FetchPrice(symbol);
0335 |         if (price > 0.0) {
0336 |             std::wstringstream ss;
0337 |             ss.precision(2);
0338 |             ss << std::fixed << symbol << L": $" << price << L"   ";
0339 |             newText += ss.str();
0340 |         }
0341 |     }
0342 | 
0343 |     if (newText.empty()) {
0344 |         newText = L"No data available   ";
0345 |     }
0346 | 
0347 |     tickerText = newText + newText;  // Duplicate for seamless loop
0348 | 
0349 |     if (hWnd) {
0350 |         InvalidateRect(hWnd, NULL, TRUE);
0351 |     }
0352 | }


================================================================================
FILE: Renderer.cpp
================================================================================

0001 | #include "Renderer.h"
0002 | #include "ConfigManager.h"
0003 | #include <windows.h>
0004 | 
0005 | HFONT Renderer::GetFont() {
0006 |     // Use the fontSize from config, with proper scaling
0007 |     int scaledSize = -MulDiv(ConfigManager::fontSize, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
0008 | 
0009 |     return CreateFont(
0010 |         scaledSize,                    // Height (negative for character height)
0011 |         0,                            // Width (0 = default)
0012 |         0,                            // Escapement
0013 |         0,                            // Orientation
0014 |         FW_NORMAL,                    // Weight
0015 |         FALSE,                        // Italic
0016 |         FALSE,                        // Underline
0017 |         FALSE,                        // StrikeOut
0018 |         DEFAULT_CHARSET,              // CharSet
0019 |         OUT_DEFAULT_PRECIS,           // OutputPrecision
0020 |         CLIP_DEFAULT_PRECIS,          // ClipPrecision
0021 |         CLEARTYPE_QUALITY,            // Quality (better rendering)
0022 |         FIXED_PITCH | FF_MODERN,      // PitchAndFamily (monospace)
0023 |         TEXT("Courier New")           // Font name
0024 |     );
0025 | }
0026 | 
0027 | COLORREF Renderer::GetTextColor() {
0028 |     // Use the colorScheme from config
0029 |     if (ConfigManager::colorScheme == L"Green") {
0030 |         return RGB(0, 255, 0);        // Bright green
0031 |     }
0032 |     else if (ConfigManager::colorScheme == L"Amber") {
0033 |         return RGB(255, 191, 0);      // Amber/orange
0034 |     }
0035 |     else if (ConfigManager::colorScheme == L"White") {
0036 |         return RGB(255, 255, 255);    // White
0037 |     }
0038 |     else if (ConfigManager::colorScheme == L"Cyan") {
0039 |         return RGB(0, 255, 255);      // Cyan
0040 |     }
0041 |     else if (ConfigManager::colorScheme == L"Red") {
0042 |         return RGB(255, 100, 100);    // Light red
0043 |     }
0044 |     else if (ConfigManager::colorScheme == L"Yellow") {
0045 |         return RGB(255, 255, 0);      // Yellow
0046 |     }
0047 | 
0048 |     return RGB(0, 255, 0);  // Default to green
0049 | }
0050 | 
0051 | COLORREF Renderer::GetBackgroundColor() {
0052 |     // Always use black background for retro look
0053 |     return RGB(0, 0, 0);
0054 | }
0055 | 
0056 | void Renderer::Render(HDC hdcWindow, const std::wstring& text, int offset, int width, int height, int charWidth) {
0057 |     if (text.empty() || width <= 0 || height <= 0) {
0058 |         return;
0059 |     }
0060 | 
0061 |     // Double buffering for smooth rendering
0062 |     HDC hdcMem = CreateCompatibleDC(hdcWindow);
0063 |     if (!hdcMem) return;
0064 | 
0065 |     HBITMAP hbmMem = CreateCompatibleBitmap(hdcWindow, width, height);
0066 |     if (!hbmMem) {
0067 |         DeleteDC(hdcMem);
0068 |         return;
0069 |     }
0070 | 
0071 |     HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);
0072 | 
0073 |     // Fill background
0074 |     RECT rect = { 0, 0, width, height };
0075 |     HBRUSH hBrush = CreateSolidBrush(GetBackgroundColor());
0076 |     FillRect(hdcMem, &rect, hBrush);
0077 |     DeleteObject(hBrush);
0078 | 
0079 |     // Set up text rendering
0080 |     HFONT hFont = GetFont();
0081 |     HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);
0082 | 
0083 |     SetTextColor(hdcMem, GetTextColor());
0084 |     SetBkMode(hdcMem, TRANSPARENT);
0085 | 
0086 |     // Get font metrics for proper vertical centering
0087 |     TEXTMETRIC tm;
0088 |     GetTextMetrics(hdcMem, &tm);
0089 |     int textHeight = tm.tmHeight;
0090 |     int yPos = (height - textHeight) / 2;  // Center vertically
0091 | 
0092 |     // Render the scrolling text
0093 |     TextOut(hdcMem, -offset, yPos, text.c_str(), (int)text.length());
0094 | 
0095 |     // Optional retro scanline effect (every other line slightly darker)
0096 |     //if (height > 20) {  // Only add scanlines if window is tall enough
0097 |     //    HPEN hPen = CreatePen(PS_SOLID, 1, RGB(0, 16, 0));  // Very dark green
0098 |     //    HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPen);
0099 | 
0100 |     //    for (int y = 1; y < height; y += 2) {
0101 |     //        MoveToEx(hdcMem, 0, y, NULL);
0102 |     //        LineTo(hdcMem, width, y);
0103 |     //    }
0104 | 
0105 |     //    SelectObject(hdcMem, hOldPen);
0106 |     //    DeleteObject(hPen);
0107 |     //}
0108 | 
0109 |     // Blit to the window
0110 |     BitBlt(hdcWindow, 0, 0, width, height, hdcMem, 0, 0, SRCCOPY);
0111 | 
0112 |     // Cleanup
0113 |     SelectObject(hdcMem, hOldFont);
0114 |     DeleteObject(hFont);
0115 |     SelectObject(hdcMem, hbmOld);
0116 |     DeleteObject(hbmMem);
0117 |     DeleteDC(hdcMem);
0118 | }


================================================================================
FILE: Renderer.h
================================================================================

0001 | #ifndef RENDERER_H
0002 | #define RENDERER_H
0003 | 
0004 | #include <windows.h>
0005 | #include <string>
0006 | 
0007 | class Renderer {
0008 | public:
0009 |     static HFONT GetFont();
0010 |     static COLORREF GetTextColor();
0011 |     static COLORREF GetBackgroundColor();
0012 |     static void Render(HDC hdc, const std::wstring& text, int offset, int width, int height, int charWidth);
0013 | };
0014 | 
0015 | #endif


================================================================================
FILE: TickerManager.h
================================================================================

0001 | #pragma once
0002 | #ifndef TICKER_MANAGER_H
0003 | #define TICKER_MANAGER_H
0004 | 
0005 | #include <string>
0006 | #include <vector>
0007 | 
0008 | extern std::vector<std::wstring> symbols;  // Defined in ConfigManager
0009 | 
0010 | #endif
